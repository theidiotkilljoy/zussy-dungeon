<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Welcome, Lord Zussy</title>
  <style>
    :root{ --bg:#0a0b10; --panel:#11131a; --edge:#1c2130; --accent:#A60000; --text:#e8ecf1; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:
        radial-gradient(1200px 800px at 50% 0%, #121622 0%, #0a0b10 70%),
        repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0 2px, transparent 2px 4px);
      color:var(--text);
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      overflow:hidden;
    }
    .crt:before{ content:""; position:fixed; inset:0; pointer-events:none; background:linear-gradient(rgba(255,255,255,.03),rgba(0,0,0,0) 2px); background-size:100% 3px; mix-blend-mode:overlay; opacity:.24; }

    .wrap{height:100%;display:grid;grid-template-rows:auto 1fr auto;gap:6px;}
    header{display:grid;place-items:center;padding-top:6px}
    h1{ margin:0; font-weight:900; letter-spacing:.5px; text-transform:lowercase; font-size:clamp(28px,5vw,48px); text-shadow:0 2px 0 #000, 0 0 24px rgba(180,139,255,.08); }

    main{display:grid;place-items:start center}
    .panel{ background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid var(--edge); border-radius:16px; padding:10px 14px; box-shadow:inset 0 0 40px rgba(0,0,0,.35), 0 24px 80px rgba(0,0,0,.55); width:min(94vw,900px); text-align:center; }
    .subtitle{opacity:.95;margin:2px 0 6px;font-size:clamp(14px,2.4vw,18px)}

    .d20-wrap{display:grid;place-items:center;gap:6px}
    #d20Canvas{ width:clamp(280px, 62vw, 560px); aspect-ratio: 1/1; min-height:280px; position:relative; }
    #d20Canvas canvas, #d20Canvas svg{ position:absolute; inset:0; width:100%; height:100%; display:block; }

    .d20{cursor:pointer; filter:drop-shadow(0 10px 30px rgba(0,0,0,.6)); transition:transform .18s ease}
    .d20:hover{transform:translateY(-1px) scale(1.004)}
    .hint{font-size:12px;opacity:.7;margin-top:6px}

    footer{display:grid;place-items:center;padding:0 0 14px}
    .enter{ display:none; background:linear-gradient(180deg, #1a2030, #0f1320); border:1px solid #2a334a; color:var(--text); font-weight:700; text-transform:uppercase; letter-spacing:.08em; padding:12px 18px; border-radius:12px; cursor:pointer; box-shadow:0 12px 30px rgba(0,0,0,.5), inset 0 0 20px rgba(166,0,0,.12); text-decoration:none; }
    .enter:focus{outline:2px solid #ff8080; outline-offset:3px}
    .enter.show{display:inline-block; animation:pop .35s ease}
    @keyframes pop{0%{transform:scale(.9);opacity:.0}100%{transform:scale(1);opacity:1}}
  </style>
</head>
<body class="crt">
  <div class="wrap">
    <header><h1>Welcome, Lord Zussy</h1></header>

    <main>
      <div class="panel">
        <div class="subtitle">Roll for initiative!</div>
        <div class="d20-wrap">
          <div id="d20Canvas" aria-label="D20 die — click to roll" class="d20" role="img"></div>
          <div class="hint">click the die</div>
        </div>
      </div>
    </main>

    <footer>
      <a id="enterBtn" class="enter" href="dungeon.html" role="button">enter the dungeon</a>
    </footer>
  </div>

  <!-- LOCAL Three.js (no CDN). Make sure this file exists: /assets/js/three.min.js -->
  <script src="assets/js/three.min.js?v=1"></script>
  <script>
    const container = document.getElementById('d20Canvas');
    const enterBtn = document.getElementById('enterBtn');
    let rolled = false;
    const easeInOut = t => t<.5 ? 2*t*t : -1+(4-2*t)*t;

    // ---------- SVG fallback (always-visible backup) ----------
    function mountSVGDie(){
      container.innerHTML = `
        <svg id="svgDie" viewBox="0 0 512 512" aria-label="D20 die (SVG)">
          <defs>
            <linearGradient id="shade" x1="0" x2="1" y1="0" y2="1">
              <stop offset="0%" stop-color="#A60000"/>
              <stop offset="60%" stop-color="#7d0000"/>
              <stop offset="100%" stop-color="#4d0000"/>
            </linearGradient>
          </defs>
          <polygon points="256,16 480,160 400,464 112,464 32,160" fill="url(#shade)" stroke="#3a0000" stroke-width="6"/>
          <g stroke="#3a0000" stroke-width="2" opacity=".9">
            <line x1="256" y1="16" x2="256" y2="496"/>
            <line x1="32" y1="160" x2="480" y2="160"/>
            <line x1="112" y1="464" x2="400" y2="464"/>
            <line x1="32" y1="160" x2="112" y2="464"/>
            <line x1="480" y1="160" x2="400" y2="464"/>
          </g>
          <text id="num" x="256" y="276" text-anchor="middle" font-size="160" font-weight="900" fill="#ffffff"
            style="paint-order: stroke; stroke: #200; stroke-width: 12px;">20</text>
        </svg>`;

      const svg = document.getElementById('svgDie');
      const num = document.getElementById('num');
      container.addEventListener('click', onClick, { once:true });
      function onClick(){ roll(); }
      function roll(){
        const seq=[3,14,7,18,11,19,9,15,6,12,17,8,13,10,16,5,4,2,1,20,32];
        const total=1200; const start=performance.now();
        function step(now){
          const t=Math.min(1,(now-start)/total); const idx=Math.floor(easeInOut(t)*(seq.length-1));
          num.textContent=seq[idx]; svg.style.transform=`rotate(${t*720}deg)`;
          if(t<1) requestAnimationFrame(step); else finalize();
        }
        requestAnimationFrame(step);
      }
      function finalize(){ num.textContent='32'; enterBtn.classList.add('show'); }
    }

    // ---------- THREE.JS (3D) — shadowed edges + face-centered label ----------
    function mountThreeDie(){
      if(!window.THREE){ mountSVGDie(); return; }
      const test=document.createElement('canvas');
      const webglOk=!!(test.getContext('webgl')||test.getContext('experimental-webgl'));
      if(!webglOk){ mountSVGDie(); return; }

      const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.innerHTML=''; container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(32, 1, 0.1, 100);
      camera.position.set(0,0.75,5.2);

      // Lights
      const hemi = new THREE.HemisphereLight(0xfff6f6, 0x0a0a12, 0.65); scene.add(hemi);
      const key = new THREE.DirectionalLight(0xffffff, 1.05); key.position.set(3,4,2); key.castShadow = true; key.shadow.mapSize.set(1024,1024); key.shadow.camera.near=1; key.shadow.camera.far=12; scene.add(key);
      const rim = new THREE.DirectionalLight(0xffc0c0, 0.6); rim.position.set(-3,2,-2); scene.add(rim);

      // Ground shadow
      const shadowMat = new THREE.ShadowMaterial({ opacity: 0.25 });
      const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), shadowMat);
      ground.rotation.x = -Math.PI/2; ground.position.y = -1.55; ground.receiveShadow = true; scene.add(ground);

      // Die
      const geo = new THREE.IcosahedronGeometry(1.2,0);
      const mat = new THREE.MeshStandardMaterial({ color:0xA60000, metalness:0.35, roughness:0.35 });
      const mesh = new THREE.Mesh(geo,mat); mesh.castShadow = true; scene.add(mesh);
      const edgeLines = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({ color:0x2a0000, transparent:true, opacity:0.9 })); scene.add(edgeLines);
      edgeLines.renderOrder = 0; mesh.renderOrder = 1;

      // Faces (centroid/normal)
      const pos = geo.attributes.position; const index = geo.index; const faces=[];
      for(let i=0;i<index.count;i+=3){
        const a=index.getX(i), b=index.getX(i+1), c=index.getX(i+2);
        const va=new THREE.Vector3().fromBufferAttribute(pos,a);
        const vb=new THREE.Vector3().fromBufferAttribute(pos,b);
        const vc=new THREE.Vector3().fromBufferAttribute(pos,c);
        const centroid=new THREE.Vector3().addVectors(va,vb).add(vc).multiplyScalar(1/3);
        const normal=new THREE.Vector3().subVectors(vb,va).cross(new THREE.Vector3().subVectors(vc,va)).normalize();
        const edgeLen=va.distanceTo(vb);
        faces.push({va,vb,vc,centroid,normal,edge:edgeLen});
      }
      const front = new THREE.Vector3(0,0,1); let landing=0, best=-Infinity;
      faces.forEach((f,i)=>{ const s=f.normal.dot(front); if(s>best){best=s; landing=i;} });
      const lf = faces[landing];

      // Number label plane on landing face
      const labelCanvas=document.createElement('canvas'); labelCanvas.width=labelCanvas.height=512; const lctx=labelCanvas.getContext('2d');
      function drawLabel(n){
        lctx.clearRect(0,0,512,512);
        const g=lctx.createRadialGradient(256,256,40,256,256,256); g.addColorStop(0,'rgba(0,0,0,0)'); g.addColorStop(1,'rgba(0,0,0,0.22)');
        lctx.fillStyle=g; lctx.beginPath(); lctx.arc(256,256,256,0,Math.PI*2); lctx.fill();
        lctx.font='900 300px system-ui, Segoe UI, Roboto, Arial'; lctx.textAlign='center'; lctx.textBaseline='middle';
        lctx.lineWidth=18; lctx.strokeStyle='#200'; lctx.fillStyle='#fff';
        lctx.strokeText(String(n),256,280); lctx.fillText(String(n),256,280);
      }
      drawLabel(20);
      const labelTex=new THREE.CanvasTexture(labelCanvas); labelTex.anisotropy = 8;
      const label=new THREE.Mesh(new THREE.PlaneGeometry(1,1), new THREE.MeshBasicMaterial({ map:labelTex, transparent:true, depthTest:false, depthWrite:false }));
      label.renderOrder = 2; mesh.add(label);
      const planeSize=lf.edge*0.92; label.scale.set(planeSize,planeSize,1);
      const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0,0,1), lf.normal.clone().normalize());
      label.quaternion.copy(q);
      label.position.copy(lf.centroid.clone().add(lf.normal.clone().multiplyScalar(0.021)));

      // Size/resize (square)
      function resize(){
        const w = container.getBoundingClientRect().width || container.clientWidth || 300; const h = w;
        renderer.setSize(w,h,false); camera.aspect=1; camera.updateProjectionMatrix();
      }
      new ResizeObserver(resize).observe(container); resize();

      // Idle spin
      let spinning=true; let t0=performance.now();
      function animate(now){ const dt=(now-t0)/1000; t0=now; if(spinning){ mesh.rotation.y+=dt*0.55; mesh.rotation.x+=dt*0.24; edgeLines.rotation.copy(mesh.rotation);} renderer.render(scene,camera); requestAnimationFrame(animate); }
      requestAnimationFrame(animate);

      function alignFaceToCamera(face){
        // Aim face normal to +Z
        const current = face.normal.clone().applyQuaternion(mesh.quaternion).normalize();
        const rotToFront = new THREE.Quaternion().setFromUnitVectors(current, new THREE.Vector3(0,0,1));
        mesh.quaternion.multiply(rotToFront); edgeLines.quaternion.copy(mesh.quaternion);
        // Twist upright
        const va=face.va.clone().applyQuaternion(mesh.quaternion);
        const vb=face.vb.clone().applyQuaternion(mesh.quaternion);
        const vc=face.vc.clone().applyQuaternion(mesh.quaternion);
        const cen=face.centroid.clone().applyQuaternion(mesh.quaternion);
        const verts=[va,vb,vc].sort((p,q)=>q.y-p.y); const top=verts[0];
        const dir=new THREE.Vector2(top.x-cen.x, top.y-cen.y);
        const ang=Math.atan2(dir.y, dir.x); const desired=Math.PI/2; const delta=desired-ang;
        mesh.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), delta));
        edgeLines.quaternion.copy(mesh.quaternion);
      }

      function roll(){
        const seq=[3,14,7,18,11,19,9,15,6,12,17,8,13,10,16,5,4,2,1,20,32];
        const total=1300; const start=performance.now();
        function step(now){
          const t=Math.min(1,(now-start)/total); const idx=Math.floor(easeInOut(t)*(seq.length-1));
          drawLabel(seq[idx]); labelTex.needsUpdate=true;
          mesh.rotation.set(mesh.rotation.x+0.12, mesh.rotation.y+0.22, mesh.rotation.z+0.18);
          edgeLines.rotation.copy(mesh.rotation);
          if(t<1) requestAnimationFrame(step); else finalize();
        }
        requestAnimationFrame(step);
      }

      function finalize(){ drawLabel(32); labelTex.needsUpdate=true; alignFaceToCamera(lf); enterBtn.classList.add('show'); }

      container.addEventListener('click', ()=>{ if(rolled) return; rolled=true; spinning=false; roll(); });

      // Safety: if canvas ends up tiny, fallback so it's never blank
      setTimeout(()=>{ const r=renderer.domElement.getBoundingClientRect(); if(r.width<40||r.height<40){ mountSVGDie(); } }, 250);
    }

    // Boot: prefer 3D using local file; fallback to SVG
    try { mountThreeDie(); } catch(e){ console.error(e); mountSVGDie(); }
  </script>
</body>
</html>
